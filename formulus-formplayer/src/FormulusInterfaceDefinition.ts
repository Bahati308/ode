/**
 * FormulusInterfaceDefinition.ts
 * 
 * This module defines the shared interface between the Formulus React Native app and the Formplayer WebView.
 * It serves as the single source of truth for the interface definition.
 * 
 * NOTE: This file should be manually copied to client projects that need to interact with the Formulus app.
 * If you've checked out the monorepo use: 
 * cp ..\formulus\src\webview\FormulusInterfaceDefinition.ts .\src\FormulusInterfaceDefinition.ts
 * 
 * Current Version: 1.0.17
 */


/**
 * Data passed to the Formulus app when a form is initialized
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string | null} observationId - The observation ID (generated by the database on first form submission). NULL if this is a new form.
 * @property {Record<string, any>} params - Additional parameters for form initialization
 * @property {Record<string, any>} savedData - Previously saved form data (for editing)
 * @property {any} [formSchema] - JSON Schema for the form structure and validation (optional)
 * @property {any} [uiSchema] - UI Schema for form rendering layout (optional)
 */
export interface FormInitData {
  formType: string;
  observationId: string | null;
  params: Record<string, any>;
  savedData: Record<string, any>;
  formSchema?: any;
  uiSchema?: any;
}

/**
 * Generic result type for media/action requests (camera, audio, signature, etc.)
 * @property {string} fieldId - The ID of the field that triggered the action
 * @property {'success' | 'cancelled' | 'error'} status - The outcome status
 * @property {string} [message] - Optional message (mainly for errors)
 * @property {T} [data] - Action-specific result data (only present on success)
 */
export interface ActionResult<T = any> {
  fieldId: string;
  status: 'success' | 'cancelled' | 'error';
  message?: string;
  data?: T;
}

/**
 * Camera-specific result data
 * @property {'image'} type - Always 'image' for camera results
 * @property {string} filename - Generated filename for the image
 * @property {string} base64 - Base64 encoded image data
 * @property {string} url - Data URL for the image
 * @property {string} timestamp - ISO timestamp when image was captured
 * @property {object} metadata - Image metadata (dimensions, size, etc.)
 */
export interface CameraResultData {
  type: 'image';
  id: string; // GUID for unique identification
  filename: string; // GUID-based filename
  uri: string; // Persistent file path for sync protocol
  url: string; // File URL for display (file://)
  timestamp: string;
  metadata: {
    width: number;
    height: number;
    size: number;
    mimeType: string;
    source: string;
    quality: number;
    originalFileName?: string;
    persistentStorage: boolean;
    storageLocation: string;
  };
}

/**
 * Audio-specific result data
 * @property {'audio'} type - Always 'audio' for audio results
 * @property {string} filename - Generated filename for the audio
 * @property {string} base64 - Base64 encoded audio data
 * @property {string} url - Data URL for the audio
 * @property {string} timestamp - ISO timestamp when audio was recorded
 * @property {object} metadata - Audio metadata (duration, format, etc.)
 */
export interface AudioResultData {
  type: 'audio';
  filename: string;
  base64: string;
  url: string;
  timestamp: string;
  metadata: {
    duration: number;
    format: string;
    sampleRate: number;
    channels: number;
    size: number;
  };
}

/**
 * Signature-specific result data
 * @property {'signature'} type - Always 'signature' for signature results
 * @property {string} filename - Generated filename for the signature
 * @property {string} base64 - Base64 encoded signature image data
 * @property {string} url - Data URL for the signature
 * @property {string} timestamp - ISO timestamp when signature was captured
 * @property {object} metadata - Signature metadata (dimensions, etc.)
 */
export interface SignatureResultData {
  type: 'signature';
  filename: string;
  base64: string;
  url: string;
  timestamp: string;
  metadata: {
    width: number;
    height: number;
    size: number;
    strokeCount: number;
  };
}

/**
 * Type aliases for specific action results
 */
export type CameraResult = ActionResult<CameraResultData>;
export type AudioResult = ActionResult<AudioResultData>;
export type SignatureResult = ActionResult<SignatureResultData>;

/**
 * @deprecated Use ActionResult<CameraResultData> instead
 * Data passed to the Formulus app when an attachment is ready
 * @property {string} fieldId - The ID of the field
 * @property {string} type - The type of the attachment
 * @property {any} [key: string] - Additional properties based on type
 */
export interface AttachmentData {
  fieldId: string;
  type: 'image' | 'location' | 'file' | 'intent' | 'subform' | 'audio' | 'signature' | 'biometric' | 'connectivity' | 'sync' | 'ml_result';
  [key: string]: any;
}

/**
 * Information about a form
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string} name - The name of the form
 * @property {string} version - The version of the form
 * @property {string[]} coreFields - The core fields of the form
 * @property {string[]} auxiliaryFields - The auxiliary fields of the form
 */
export interface FormInfo {
  formType: string;
  name: string;
  version: string;
  coreFields: string[];
  auxiliaryFields: string[];
}

/**
 * Information about a form observation
 * @property {string} observationId - The observation ID (generated by the database on first form submission)
 * @property {Date} createdAt - The date the observation was created
 * @property {Date} updatedAt - The date the observation was last updated
 * @property {Date} syncedAt - The date the observation was synced
 * @property {boolean} isDraft - Whether the observation is a draft
 * @property {boolean} deleted - Whether the observation has been deleted
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string} formVersion - The version of the form
 * @property {Record<string, any>} data - The form data
 */
export interface FormObservation {
  observationId: string;
  createdAt: Date;
  updatedAt: Date;
  syncedAt: Date;
  isDraft: boolean;
  deleted: boolean;
  formType: string;
  formVersion: string;
  data: Record<string, any>;
}

/**
 * Interface for the Formulus app methods that will be injected into the WebViews for custom_app and FormPlayer
 * @namespace formulus
 */
export interface FormulusInterface {
  /**
   * Get the current version of the Formulus API
   * @returns {Promise<string>} The API version
   */
  getVersion(): Promise<string>;

  /**
   * Get a list of available forms
   * @returns {Promise<FormInfo[]>} Array of form information objects
   */
  getAvailableForms(): Promise<FormInfo[]>;

  /**
   * Open Formplayer with the specified form
   * @param {string} formType - The identifier of the formtype to open
   * @param {Object} params - Additional parameters for form initialization
   * @param {Object} savedData - Previously saved form data (for editing)
   * @returns {Promise<void>}
   */
  openFormplayer(formType: string, params: Record<string, any>, savedData: Record<string, any>): Promise<void>;

  /**
   * Get observations for a specific form
   * @param {string} formType - The identifier of the formtype
   * @param {boolean} [isDraft=false] - Whether to include draft observations
   * @param {boolean} [includeDeleted=false] - Whether to include deleted observations
   * @returns {Promise<FormObservation[]>} Array of form observations
   */
  getObservations(formType: string, isDraft?: boolean, includeDeleted?: boolean): Promise<FormObservation[]>;

  /**
   * Save partial form data
   * @param {string} formType - The identifier of the formtype
   * @param {Object} data - The form data to save
   * @returns {Promise<void>}
   */
  savePartial(formType: string, data: Record<string, any>): Promise<void>;

  /**
   * Submit a completed form
   * @param {string} formType - The identifier of the formtype
   * @param {Object} finalData - The final form data to submit
   * @returns {Promise<string>} The observationId of the submitted form
   */
  submitObservation(formType: string, finalData: Record<string, any>): Promise<string>;

  /**
   * Update an existing form
   * @param {string} observationId - The identifier of the observation
   * @param {string} formType - The identifier of the formtype
   * @param {Object} finalData - The final form data to update
   * @returns {Promise<string>} The observationId of the updated form
   */
  updateObservation(observationId: string, formType: string, finalData: Record<string, any>): Promise<string>;

  /**
   * Request camera access for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<CameraResult>} Promise that resolves with camera result or rejects on error/cancellation
   */
  requestCamera(fieldId: string): Promise<CameraResult>;

  /**
   * Request location for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<void>}
   */
  requestLocation(fieldId: string): Promise<void>;

  /**
   * Request file selection for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<void>}
   */
  requestFile(fieldId: string): Promise<void>;

  /**
   * Launch an external intent
   * @param {string} fieldId - The ID of the field
   * @param {Object} intentSpec - The intent specification
   * @returns {Promise<void>}
   */
  launchIntent(fieldId: string, intentSpec: Record<string, any>): Promise<void>;

  /**
   * Call a subform
   * @param {string} fieldId - The ID of the field
   * @param {string} formType - The ID of the subform
   * @param {Object} options - Additional options for the subform
   * @returns {Promise<void>}
   */
  callSubform(fieldId: string, formType: string, options: Record<string, any>): Promise<void>;

  /**
   * Request audio recording for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<AudioResult>} Promise that resolves with audio result or rejects on error/cancellation
   */
  requestAudio(fieldId: string): Promise<AudioResult>;

  /**
   * Request signature for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<SignatureResult>} Promise that resolves with signature result or rejects on error/cancellation
   */
  requestSignature(fieldId: string): Promise<SignatureResult>;

  /**
   * Request biometric authentication
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<void>}
   */
  requestBiometric(fieldId: string): Promise<void>;

  /**
   * Request the current connectivity status
   * @returns {Promise<void>}
   */
  requestConnectivityStatus(): Promise<void>;

  /**
   * Request the current sync status
   * @returns {Promise<void>}
   */
  requestSyncStatus(): Promise<void>;

  /**
   * Run a local ML model
   * @param {string} fieldId - The ID of the field
   * @param {string} modelId - The ID of the model to run
   * @param {Object} input - The input data for the model
   * @returns {Promise<void>}
   */
  runLocalModel(fieldId: string, modelId: string, input: Record<string, any>): Promise<void>;
}

/**
 * Interface for callback methods that the Formplayer WebView implements
 */
export interface FormulusCallbacks {
  onFormInit?: (formType: string, observationId: string | null, params: Record<string, any>, savedData: Record<string, any>) => void;
  onSavePartialComplete?: (formType: string, observationId: string | null, success: boolean) => void;
  onFormulusReady?: () => void;
  onReceiveFocus?: () => void;
}

/**
 * Current version of the interface
 */
export const FORMULUS_INTERFACE_VERSION = "1.0.1";

/**
 * Check if the current interface version is compatible with the required version
 */
export function isCompatibleVersion(requiredVersion: string): boolean {
  // Simple version comparison - can be enhanced for semantic versioning
  return FORMULUS_INTERFACE_VERSION >= requiredVersion;
}

// Extend the global interface to include the Formulus interface
declare global {
  var formulus: FormulusInterface | undefined;
  var onFormInit: FormulusCallbacks['onFormInit'];
  var onSavePartialComplete: FormulusCallbacks['onSavePartialComplete'];
  var onFormulusReady: FormulusCallbacks['onFormulusReady'];
  var onReceiveFocus: FormulusCallbacks['onReceiveFocus'];
}
