/* tslint:disable */
/* eslint-disable */
/**
 * Synkronus API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AppBundleChangeLog
 */
export interface AppBundleChangeLog {
    /**
     * 
     * @type {string}
     * @memberof AppBundleChangeLog
     */
    'compare_version_a': string;
    /**
     * 
     * @type {string}
     * @memberof AppBundleChangeLog
     */
    'compare_version_b': string;
    /**
     * 
     * @type {boolean}
     * @memberof AppBundleChangeLog
     */
    'form_changes': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppBundleChangeLog
     */
    'ui_changes': boolean;
    /**
     * 
     * @type {Array<FormDiff>}
     * @memberof AppBundleChangeLog
     */
    'new_forms'?: Array<FormDiff>;
    /**
     * 
     * @type {Array<FormDiff>}
     * @memberof AppBundleChangeLog
     */
    'removed_forms'?: Array<FormDiff>;
    /**
     * 
     * @type {Array<FormModification>}
     * @memberof AppBundleChangeLog
     */
    'modified_forms'?: Array<FormModification>;
}
/**
 * 
 * @export
 * @interface AppBundleFile
 */
export interface AppBundleFile {
    /**
     * 
     * @type {string}
     * @memberof AppBundleFile
     */
    'path': string;
    /**
     * 
     * @type {number}
     * @memberof AppBundleFile
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof AppBundleFile
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof AppBundleFile
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof AppBundleFile
     */
    'modTime': string;
}
/**
 * 
 * @export
 * @interface AppBundleManifest
 */
export interface AppBundleManifest {
    /**
     * 
     * @type {Array<AppBundleFile>}
     * @memberof AppBundleManifest
     */
    'files': Array<AppBundleFile>;
    /**
     * 
     * @type {string}
     * @memberof AppBundleManifest
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof AppBundleManifest
     */
    'generatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AppBundleManifest
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface AppBundlePushResponse
 */
export interface AppBundlePushResponse {
    /**
     * 
     * @type {string}
     * @memberof AppBundlePushResponse
     */
    'message': string;
    /**
     * 
     * @type {AppBundleManifest}
     * @memberof AppBundlePushResponse
     */
    'manifest': AppBundleManifest;
}
/**
 * 
 * @export
 * @interface AppBundleVersions
 */
export interface AppBundleVersions {
    /**
     * 
     * @type {Array<string>}
     * @memberof AppBundleVersions
     */
    'versions': Array<string>;
}
/**
 * 
 * @export
 * @interface AttachmentManifestRequest
 */
export interface AttachmentManifestRequest {
    /**
     * Unique identifier for the client requesting the manifest
     * @type {string}
     * @memberof AttachmentManifestRequest
     */
    'client_id': string;
    /**
     * Data version number from which to get attachment changes (0 for all attachments)
     * @type {number}
     * @memberof AttachmentManifestRequest
     */
    'since_version': number;
}
/**
 * 
 * @export
 * @interface AttachmentManifestResponse
 */
export interface AttachmentManifestResponse {
    /**
     * Current database version number
     * @type {number}
     * @memberof AttachmentManifestResponse
     */
    'current_version': number;
    /**
     * List of attachment operations to perform
     * @type {Array<AttachmentOperation>}
     * @memberof AttachmentManifestResponse
     */
    'operations': Array<AttachmentOperation>;
    /**
     * Total size in bytes of all attachments to download
     * @type {number}
     * @memberof AttachmentManifestResponse
     */
    'total_download_size'?: number;
    /**
     * 
     * @type {AttachmentManifestResponseOperationCount}
     * @memberof AttachmentManifestResponse
     */
    'operation_count'?: AttachmentManifestResponseOperationCount;
}
/**
 * Count of operations by type
 * @export
 * @interface AttachmentManifestResponseOperationCount
 */
export interface AttachmentManifestResponseOperationCount {
    /**
     * 
     * @type {number}
     * @memberof AttachmentManifestResponseOperationCount
     */
    'download'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttachmentManifestResponseOperationCount
     */
    'delete'?: number;
}
/**
 * 
 * @export
 * @interface AttachmentOperation
 */
export interface AttachmentOperation {
    /**
     * Operation to perform on the attachment
     * @type {string}
     * @memberof AttachmentOperation
     */
    'operation': AttachmentOperationOperationEnum;
    /**
     * Unique identifier for the attachment
     * @type {string}
     * @memberof AttachmentOperation
     */
    'attachment_id': string;
    /**
     * URL to download the attachment (only present for download operations)
     * @type {string}
     * @memberof AttachmentOperation
     */
    'download_url'?: string;
    /**
     * Size of the attachment in bytes (only present for download operations)
     * @type {number}
     * @memberof AttachmentOperation
     */
    'size'?: number;
    /**
     * MIME type of the attachment (only present for download operations)
     * @type {string}
     * @memberof AttachmentOperation
     */
    'content_type'?: string;
    /**
     * Version when this attachment was created/modified/deleted
     * @type {number}
     * @memberof AttachmentOperation
     */
    'version'?: number;
}

export const AttachmentOperationOperationEnum = {
    Download: 'download',
    Delete: 'delete'
} as const;

export type AttachmentOperationOperationEnum = typeof AttachmentOperationOperationEnum[keyof typeof AttachmentOperationOperationEnum];

/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {number}
     * @memberof AuthResponse
     */
    'expiresAt': number;
}
/**
 * 
 * @export
 * @interface BuildInfo
 */
export interface BuildInfo {
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    'build_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    'go_version'?: string;
}
/**
 * 
 * @export
 * @interface ChangeLog
 */
export interface ChangeLog {
    /**
     * 
     * @type {string}
     * @memberof ChangeLog
     */
    'compare_version_a'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeLog
     */
    'compare_version_b'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeLog
     */
    'form_changes'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeLog
     */
    'ui_changes'?: boolean;
    /**
     * 
     * @type {Array<FormDiff>}
     * @memberof ChangeLog
     */
    'new_forms'?: Array<FormDiff>;
    /**
     * 
     * @type {Array<FormDiff>}
     * @memberof ChangeLog
     */
    'removed_forms'?: Array<FormDiff>;
    /**
     * 
     * @type {Array<FormModification>}
     * @memberof ChangeLog
     */
    'modified_forms'?: Array<FormModification>;
}
/**
 * 
 * @export
 * @interface ChangePassword200Response
 */
export interface ChangePassword200Response {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * Current password for verification
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'currentPassword': string;
    /**
     * New password to set
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * New user\'s username
     * @type {string}
     * @memberof CreateUserRequest
     */
    'username': string;
    /**
     * New user\'s password
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
    /**
     * User\'s role
     * @type {string}
     * @memberof CreateUserRequest
     */
    'role': CreateUserRequestRoleEnum;
}

export const CreateUserRequestRoleEnum = {
    ReadOnly: 'read-only',
    ReadWrite: 'read-write',
    Admin: 'admin'
} as const;

export type CreateUserRequestRoleEnum = typeof CreateUserRequestRoleEnum[keyof typeof CreateUserRequestRoleEnum];

/**
 * 
 * @export
 * @interface DatabaseInfo
 */
export interface DatabaseInfo {
    /**
     * 
     * @type {string}
     * @memberof DatabaseInfo
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseInfo
     */
    'database_name'?: string;
}
/**
 * 
 * @export
 * @interface DeleteUser200Response
 */
export interface DeleteUser200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteUser200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface FieldChange
 */
export interface FieldChange {
    /**
     * 
     * @type {string}
     * @memberof FieldChange
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldChange
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface FormDiff
 */
export interface FormDiff {
    /**
     * 
     * @type {string}
     * @memberof FormDiff
     */
    'form'?: string;
}
/**
 * 
 * @export
 * @interface FormModification
 */
export interface FormModification {
    /**
     * 
     * @type {string}
     * @memberof FormModification
     */
    'form'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormModification
     */
    'schema_changed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormModification
     */
    'ui_changed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormModification
     */
    'core_changed'?: boolean;
    /**
     * 
     * @type {Array<FieldChange>}
     * @memberof FormModification
     */
    'added_fields'?: Array<FieldChange>;
    /**
     * 
     * @type {Array<FieldChange>}
     * @memberof FormModification
     */
    'removed_fields'?: Array<FieldChange>;
}
/**
 * 
 * @export
 * @interface GetHealth200Response
 */
export interface GetHealth200Response {
    /**
     * 
     * @type {string}
     * @memberof GetHealth200Response
     */
    'status'?: GetHealth200ResponseStatusEnum;
    /**
     * Current server time
     * @type {string}
     * @memberof GetHealth200Response
     */
    'timestamp'?: string;
    /**
     * Current API version
     * @type {string}
     * @memberof GetHealth200Response
     */
    'version'?: string;
}

export const GetHealth200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetHealth200ResponseStatusEnum = typeof GetHealth200ResponseStatusEnum[keyof typeof GetHealth200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetHealth503Response
 */
export interface GetHealth503Response {
    /**
     * 
     * @type {string}
     * @memberof GetHealth503Response
     */
    'status'?: GetHealth503ResponseStatusEnum;
    /**
     * Description of the error
     * @type {string}
     * @memberof GetHealth503Response
     */
    'error'?: string;
    /**
     * Current server time
     * @type {string}
     * @memberof GetHealth503Response
     */
    'timestamp'?: string;
}

export const GetHealth503ResponseStatusEnum = {
    Error: 'error'
} as const;

export type GetHealth503ResponseStatusEnum = typeof GetHealth503ResponseStatusEnum[keyof typeof GetHealth503ResponseStatusEnum];

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * User\'s username
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Observation
 */
export interface Observation {
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'observation_id': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'form_type': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'form_version': string;
    /**
     * Arbitrary JSON object containing form data
     * @type {object}
     * @memberof Observation
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'synced_at'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Observation
     */
    'deleted': boolean;
    /**
     * 
     * @type {ObservationGeolocation}
     * @memberof Observation
     */
    'geolocation'?: ObservationGeolocation | null;
}
/**
 * Optional geolocation data for the observation
 * @export
 * @interface ObservationGeolocation
 */
export interface ObservationGeolocation {
    /**
     * Latitude in decimal degrees
     * @type {number}
     * @memberof ObservationGeolocation
     */
    'latitude'?: number;
    /**
     * Longitude in decimal degrees
     * @type {number}
     * @memberof ObservationGeolocation
     */
    'longitude'?: number;
    /**
     * Horizontal accuracy in meters
     * @type {number}
     * @memberof ObservationGeolocation
     */
    'accuracy'?: number;
    /**
     * Elevation in meters above sea level
     * @type {number}
     * @memberof ObservationGeolocation
     */
    'altitude'?: number | null;
    /**
     * Vertical accuracy in meters
     * @type {number}
     * @memberof ObservationGeolocation
     */
    'altitude_accuracy'?: number | null;
}
/**
 * 
 * @export
 * @interface ProblemDetail
 */
export interface ProblemDetail {
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetail
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'instance'?: string;
    /**
     * 
     * @type {Array<ProblemDetailErrorsInner>}
     * @memberof ProblemDetail
     */
    'errors'?: Array<ProblemDetailErrorsInner>;
}
/**
 * 
 * @export
 * @interface ProblemDetailErrorsInner
 */
export interface ProblemDetailErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ProblemDetailErrorsInner
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetailErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * Refresh token obtained from login or previous refresh
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ResetUserPassword200Response
 */
export interface ResetUserPassword200Response {
    /**
     * 
     * @type {string}
     * @memberof ResetUserPassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ResetUserPasswordRequest
 */
export interface ResetUserPasswordRequest {
    /**
     * Username of the user whose password is being reset
     * @type {string}
     * @memberof ResetUserPasswordRequest
     */
    'username': string;
    /**
     * New password for the user
     * @type {string}
     * @memberof ResetUserPasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {string}
     * @memberof ServerInfo
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface SwitchAppBundleVersion200Response
 */
export interface SwitchAppBundleVersion200Response {
    /**
     * 
     * @type {string}
     * @memberof SwitchAppBundleVersion200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SyncPullRequest
 */
export interface SyncPullRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncPullRequest
     */
    'client_id': string;
    /**
     * 
     * @type {SyncPullRequestSince}
     * @memberof SyncPullRequest
     */
    'since'?: SyncPullRequestSince;
    /**
     * 
     * @type {Array<string>}
     * @memberof SyncPullRequest
     */
    'schema_types'?: Array<string>;
}
/**
 * Optional pagination cursor indicating the last seen change
 * @export
 * @interface SyncPullRequestSince
 */
export interface SyncPullRequestSince {
    /**
     * 
     * @type {number}
     * @memberof SyncPullRequestSince
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof SyncPullRequestSince
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface SyncPullResponse
 */
export interface SyncPullResponse {
    /**
     * Current database version number that increments with each update
     * @type {number}
     * @memberof SyncPullResponse
     */
    'current_version': number;
    /**
     * 
     * @type {Array<Observation>}
     * @memberof SyncPullResponse
     */
    'records': Array<Observation>;
    /**
     * Version number of the last change included in this response. Use this as the next \'since.version\' for pagination.
     * @type {number}
     * @memberof SyncPullResponse
     */
    'change_cutoff': number;
    /**
     * Indicates if there are more records available beyond this response
     * @type {boolean}
     * @memberof SyncPullResponse
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SyncPullResponse
     */
    'sync_format_version'?: string;
}
/**
 * 
 * @export
 * @interface SyncPushRequest
 */
export interface SyncPushRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncPushRequest
     */
    'transmission_id': string;
    /**
     * 
     * @type {string}
     * @memberof SyncPushRequest
     */
    'client_id': string;
    /**
     * 
     * @type {Array<Observation>}
     * @memberof SyncPushRequest
     */
    'records': Array<Observation>;
}
/**
 * 
 * @export
 * @interface SyncPushResponse
 */
export interface SyncPushResponse {
    /**
     * Current database version number after processing the push
     * @type {number}
     * @memberof SyncPushResponse
     */
    'current_version': number;
    /**
     * 
     * @type {number}
     * @memberof SyncPushResponse
     */
    'success_count': number;
    /**
     * 
     * @type {Array<object>}
     * @memberof SyncPushResponse
     */
    'failed_records'?: Array<object>;
    /**
     * 
     * @type {Array<SyncPushResponseWarningsInner>}
     * @memberof SyncPushResponse
     */
    'warnings'?: Array<SyncPushResponseWarningsInner>;
}
/**
 * 
 * @export
 * @interface SyncPushResponseWarningsInner
 */
export interface SyncPushResponseWarningsInner {
    /**
     * 
     * @type {string}
     * @memberof SyncPushResponseWarningsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SyncPushResponseWarningsInner
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SyncPushResponseWarningsInner
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'os'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'architecture'?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'cpus'?: number;
}
/**
 * 
 * @export
 * @interface SystemVersionInfo
 */
export interface SystemVersionInfo {
    /**
     * 
     * @type {ServerInfo}
     * @memberof SystemVersionInfo
     */
    'server'?: ServerInfo;
    /**
     * 
     * @type {DatabaseInfo}
     * @memberof SystemVersionInfo
     */
    'database'?: DatabaseInfo;
    /**
     * 
     * @type {SystemInfo}
     * @memberof SystemVersionInfo
     */
    'system'?: SystemInfo;
    /**
     * 
     * @type {BuildInfo}
     * @memberof SystemVersionInfo
     */
    'build'?: BuildInfo;
}
/**
 * 
 * @export
 * @interface UploadAttachment200Response
 */
export interface UploadAttachment200Response {
    /**
     * 
     * @type {string}
     * @memberof UploadAttachment200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'role': UserResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt': string;
}

export const UserResponseRoleEnum = {
    ReadOnly: 'read-only',
    ReadWrite: 'read-write',
    Admin: 'admin'
} as const;

export type UserResponseRoleEnum = typeof UserResponseRoleEnum[keyof typeof UserResponseRoleEnum];


/**
 * DataExportApi - axios parameter creator
 * @export
 */
export const DataExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together. 
         * @summary Download a ZIP archive of Parquet exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParquetExportZip: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dataexport/parquet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExportApi - functional programming interface
 * @export
 */
export const DataExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together. 
         * @summary Download a ZIP archive of Parquet exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParquetExportZip(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParquetExportZip(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataExportApi.getParquetExportZip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataExportApi - factory interface
 * @export
 */
export const DataExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataExportApiFp(configuration)
    return {
        /**
         * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together. 
         * @summary Download a ZIP archive of Parquet exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParquetExportZip(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getParquetExportZip(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataExportApi - object-oriented interface
 * @export
 * @class DataExportApi
 * @extends {BaseAPI}
 */
export class DataExportApi extends BaseAPI {
    /**
     * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together. 
     * @summary Download a ZIP archive of Parquet exports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportApi
     */
    public getParquetExportZip(options?: RawAxiosRequestConfig) {
        return DataExportApiFp(this.configuration).getParquetExportZip(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change password for the currently authenticated user
         * @summary Change user password (authenticated user)\'s password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/users/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if an attachment exists
         * @param {string} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAttachmentExists: async (attachmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('checkAttachmentExists', 'attachmentId', attachmentId)
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user with specified username, password, and role
         * @summary Create a new user (admin only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user by username
         * @summary Delete a user (admin only)
         * @param {string} username Username of the user to delete
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a specific file from the app bundle
         * @param {string} path 
         * @param {boolean} [preview] If true, returns the file from the latest version including unreleased changes
         * @param {string} [ifNoneMatch] 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAppBundleFile: async (path: string, preview?: boolean, ifNoneMatch?: string, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('downloadAppBundleFile', 'path', path)
            const localVarPath = `/app-bundle/download/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (preview !== undefined) {
                localVarQueryParameter['preview'] = preview;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an attachment by ID
         * @param {string} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: async (attachmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('downloadAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compares two versions of the app bundle and returns detailed changes
         * @summary Get changes between two app bundle versions
         * @param {string} [current] The current version (defaults to latest)
         * @param {string} [target] The target version to compare against (defaults to previous version)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleChanges: async (current?: string, target?: string, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-bundle/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current custom app bundle manifest
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleManifest: async (xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-bundle/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of available app bundle versions
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleVersions: async (xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-bundle/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
         * @summary Get attachment manifest for incremental sync
         * @param {AttachmentManifestRequest} attachmentManifestRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentManifest: async (attachmentManifestRequest: AttachmentManifestRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentManifestRequest' is not null or undefined
            assertParamExists('getAttachmentManifest', 'attachmentManifestRequest', attachmentManifestRequest)
            const localVarPath = `/attachments/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachmentManifestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns detailed version information about the server, including build information and system details
         * @summary Get server version and system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users in the system. Admin access required.
         * @summary List all users (admin only)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a JWT token by providing username and password
         * @summary Authenticate user and return JWT tokens
         * @param {LoginRequest} loginRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a new app bundle (admin only)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {File} [bundle] ZIP file containing the new app bundle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushAppBundle: async (xApiVersion?: string, bundle?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-bundle/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (bundle !== undefined) { 
                localVarFormParams.append('bundle', bundle as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a new JWT token using a refresh token
         * @summary Refresh JWT token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password for a specified user
         * @summary Reset user password (admin only)
         * @param {ResetUserPasswordRequest} resetUserPasswordRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: async (resetUserPasswordRequest: ResetUserPasswordRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetUserPasswordRequest' is not null or undefined
            assertParamExists('resetUserPassword', 'resetUserPasswordRequest', resetUserPasswordRequest)
            const localVarPath = `/users/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Switch to a specific app bundle version (admin only)
         * @param {string} version Version identifier to switch to
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchAppBundleVersion: async (version: string, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('switchAppBundleVersion', 'version', version)
            const localVarPath = `/app-bundle/switch/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}` → Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}` → Response: `change_cutoff: 200, has_more: false` 
         * @summary Pull updated records since last sync
         * @param {SyncPullRequest} syncPullRequest 
         * @param {string} [schemaType] Filter by schemaType
         * @param {number} [limit] Maximum number of records to return
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPull: async (syncPullRequest: SyncPullRequest, schemaType?: string, limit?: number, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncPullRequest' is not null or undefined
            assertParamExists('syncPull', 'syncPullRequest', syncPullRequest)
            const localVarPath = `/sync/pull`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (schemaType !== undefined) {
                localVarQueryParameter['schemaType'] = schemaType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPullRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Push new or updated records to the server
         * @param {SyncPushRequest} syncPushRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPush: async (syncPushRequest: SyncPushRequest, xApiVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncPushRequest' is not null or undefined
            assertParamExists('syncPush', 'syncPushRequest', syncPushRequest)
            const localVarPath = `/sync/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPushRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a new attachment with specified ID
         * @param {string} attachmentId 
         * @param {File} file The binary file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: async (attachmentId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('uploadAttachment', 'attachmentId', attachmentId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadAttachment', 'file', file)
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Change password for the currently authenticated user
         * @summary Change user password (authenticated user)\'s password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if an attachment exists
         * @param {string} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAttachmentExists(attachmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAttachmentExists(attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.checkAttachmentExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user with specified username, password, and role
         * @summary Create a new user (admin only)
         * @param {CreateUserRequest} createUserRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user by username
         * @summary Delete a user (admin only)
         * @param {string} username Username of the user to delete
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a specific file from the app bundle
         * @param {string} path 
         * @param {boolean} [preview] If true, returns the file from the latest version including unreleased changes
         * @param {string} [ifNoneMatch] 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAppBundleFile(path: string, preview?: boolean, ifNoneMatch?: string, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAppBundleFile(path, preview, ifNoneMatch, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadAppBundleFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download an attachment by ID
         * @param {string} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAttachment(attachmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAttachment(attachmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Compares two versions of the app bundle and returns detailed changes
         * @summary Get changes between two app bundle versions
         * @param {string} [current] The current version (defaults to latest)
         * @param {string} [target] The target version to compare against (defaults to previous version)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppBundleChanges(current?: string, target?: string, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppBundleChanges(current, target, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAppBundleChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current custom app bundle manifest
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppBundleManifest(xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppBundleManifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppBundleManifest(xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAppBundleManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of available app bundle versions
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppBundleVersions(xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppBundleVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppBundleVersions(xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAppBundleVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
         * @summary Get attachment manifest for incremental sync
         * @param {AttachmentManifestRequest} attachmentManifestRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachmentManifest(attachmentManifestRequest: AttachmentManifestRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentManifestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentManifest(attachmentManifestRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAttachmentManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns detailed version information about the server, including build information and system details
         * @summary Get server version and system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemVersionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users in the system. Admin access required.
         * @summary List all users (admin only)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtain a JWT token by providing username and password
         * @summary Authenticate user and return JWT tokens
         * @param {LoginRequest} loginRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a new app bundle (admin only)
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {File} [bundle] ZIP file containing the new app bundle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushAppBundle(xApiVersion?: string, bundle?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppBundlePushResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushAppBundle(xApiVersion, bundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pushAppBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtain a new JWT token using a refresh token
         * @summary Refresh JWT token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset password for a specified user
         * @summary Reset user password (admin only)
         * @param {ResetUserPasswordRequest} resetUserPasswordRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserPassword(resetUserPasswordRequest: ResetUserPasswordRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserPassword(resetUserPasswordRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Switch to a specific app bundle version (admin only)
         * @param {string} version Version identifier to switch to
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchAppBundleVersion(version: string, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwitchAppBundleVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchAppBundleVersion(version, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.switchAppBundleVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}` → Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}` → Response: `change_cutoff: 200, has_more: false` 
         * @summary Pull updated records since last sync
         * @param {SyncPullRequest} syncPullRequest 
         * @param {string} [schemaType] Filter by schemaType
         * @param {number} [limit] Maximum number of records to return
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPull(syncPullRequest: SyncPullRequest, schemaType?: string, limit?: number, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncPullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncPull(syncPullRequest, schemaType, limit, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncPull']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Push new or updated records to the server
         * @param {SyncPushRequest} syncPushRequest 
         * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPush(syncPushRequest: SyncPushRequest, xApiVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncPushResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncPush(syncPushRequest, xApiVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncPush']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a new attachment with specified ID
         * @param {string} attachmentId 
         * @param {File} file The binary file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAttachment(attachmentId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadAttachment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAttachment(attachmentId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Change password for the currently authenticated user
         * @summary Change user password (authenticated user)\'s password
         * @param {DefaultApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters: DefaultApiChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChangePassword200Response> {
            return localVarFp.changePassword(requestParameters.changePasswordRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if an attachment exists
         * @param {DefaultApiCheckAttachmentExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAttachmentExists(requestParameters: DefaultApiCheckAttachmentExistsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkAttachmentExists(requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user with specified username, password, and role
         * @summary Create a new user (admin only)
         * @param {DefaultApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: DefaultApiCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createUser(requestParameters.createUserRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user by username
         * @summary Delete a user (admin only)
         * @param {DefaultApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: DefaultApiDeleteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteUser200Response> {
            return localVarFp.deleteUser(requestParameters.username, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a specific file from the app bundle
         * @param {DefaultApiDownloadAppBundleFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAppBundleFile(requestParameters: DefaultApiDownloadAppBundleFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadAppBundleFile(requestParameters.path, requestParameters.preview, requestParameters.ifNoneMatch, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an attachment by ID
         * @param {DefaultApiDownloadAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(requestParameters: DefaultApiDownloadAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadAttachment(requestParameters.attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Compares two versions of the app bundle and returns detailed changes
         * @summary Get changes between two app bundle versions
         * @param {DefaultApiGetAppBundleChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleChanges(requestParameters: DefaultApiGetAppBundleChangesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChangeLog> {
            return localVarFp.getAppBundleChanges(requestParameters.current, requestParameters.target, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current custom app bundle manifest
         * @param {DefaultApiGetAppBundleManifestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleManifest(requestParameters: DefaultApiGetAppBundleManifestRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AppBundleManifest> {
            return localVarFp.getAppBundleManifest(requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of available app bundle versions
         * @param {DefaultApiGetAppBundleVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppBundleVersions(requestParameters: DefaultApiGetAppBundleVersionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AppBundleVersions> {
            return localVarFp.getAppBundleVersions(requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
         * @summary Get attachment manifest for incremental sync
         * @param {DefaultApiGetAttachmentManifestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentManifest(requestParameters: DefaultApiGetAttachmentManifestRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentManifestResponse> {
            return localVarFp.getAttachmentManifest(requestParameters.attachmentManifestRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns detailed version information about the server, including build information and system details
         * @summary Get server version and system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: RawAxiosRequestConfig): AxiosPromise<SystemVersionInfo> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users in the system. Admin access required.
         * @summary List all users (admin only)
         * @param {DefaultApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(requestParameters: DefaultApiListUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponse>> {
            return localVarFp.listUsers(requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain a JWT token by providing username and password
         * @summary Authenticate user and return JWT tokens
         * @param {DefaultApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: DefaultApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.login(requestParameters.loginRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a new app bundle (admin only)
         * @param {DefaultApiPushAppBundleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushAppBundle(requestParameters: DefaultApiPushAppBundleRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AppBundlePushResponse> {
            return localVarFp.pushAppBundle(requestParameters.xApiVersion, requestParameters.bundle, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain a new JWT token using a refresh token
         * @summary Refresh JWT token
         * @param {DefaultApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: DefaultApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.refreshToken(requestParameters.refreshTokenRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password for a specified user
         * @summary Reset user password (admin only)
         * @param {DefaultApiResetUserPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(requestParameters: DefaultApiResetUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResetUserPassword200Response> {
            return localVarFp.resetUserPassword(requestParameters.resetUserPasswordRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Switch to a specific app bundle version (admin only)
         * @param {DefaultApiSwitchAppBundleVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchAppBundleVersion(requestParameters: DefaultApiSwitchAppBundleVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SwitchAppBundleVersion200Response> {
            return localVarFp.switchAppBundleVersion(requestParameters.version, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}` → Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}` → Response: `change_cutoff: 200, has_more: false` 
         * @summary Pull updated records since last sync
         * @param {DefaultApiSyncPullRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPull(requestParameters: DefaultApiSyncPullRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncPullResponse> {
            return localVarFp.syncPull(requestParameters.syncPullRequest, requestParameters.schemaType, requestParameters.limit, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Push new or updated records to the server
         * @param {DefaultApiSyncPushRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPush(requestParameters: DefaultApiSyncPushRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncPushResponse> {
            return localVarFp.syncPush(requestParameters.syncPushRequest, requestParameters.xApiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a new attachment with specified ID
         * @param {DefaultApiUploadAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(requestParameters: DefaultApiUploadAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadAttachment200Response> {
            return localVarFp.uploadAttachment(requestParameters.attachmentId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePassword operation in DefaultApi.
 * @export
 * @interface DefaultApiChangePasswordRequest
 */
export interface DefaultApiChangePasswordRequest {
    /**
     * 
     * @type {ChangePasswordRequest}
     * @memberof DefaultApiChangePassword
     */
    readonly changePasswordRequest: ChangePasswordRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiChangePassword
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for checkAttachmentExists operation in DefaultApi.
 * @export
 * @interface DefaultApiCheckAttachmentExistsRequest
 */
export interface DefaultApiCheckAttachmentExistsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiCheckAttachmentExists
     */
    readonly attachmentId: string
}

/**
 * Request parameters for createUser operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateUserRequest
 */
export interface DefaultApiCreateUserRequest {
    /**
     * 
     * @type {CreateUserRequest}
     * @memberof DefaultApiCreateUser
     */
    readonly createUserRequest: CreateUserRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiCreateUser
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for deleteUser operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteUserRequest
 */
export interface DefaultApiDeleteUserRequest {
    /**
     * Username of the user to delete
     * @type {string}
     * @memberof DefaultApiDeleteUser
     */
    readonly username: string

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiDeleteUser
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for downloadAppBundleFile operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadAppBundleFileRequest
 */
export interface DefaultApiDownloadAppBundleFileRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDownloadAppBundleFile
     */
    readonly path: string

    /**
     * If true, returns the file from the latest version including unreleased changes
     * @type {boolean}
     * @memberof DefaultApiDownloadAppBundleFile
     */
    readonly preview?: boolean

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDownloadAppBundleFile
     */
    readonly ifNoneMatch?: string

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiDownloadAppBundleFile
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for downloadAttachment operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadAttachmentRequest
 */
export interface DefaultApiDownloadAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDownloadAttachment
     */
    readonly attachmentId: string
}

/**
 * Request parameters for getAppBundleChanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleChangesRequest
 */
export interface DefaultApiGetAppBundleChangesRequest {
    /**
     * The current version (defaults to latest)
     * @type {string}
     * @memberof DefaultApiGetAppBundleChanges
     */
    readonly current?: string

    /**
     * The target version to compare against (defaults to previous version)
     * @type {string}
     * @memberof DefaultApiGetAppBundleChanges
     */
    readonly target?: string

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiGetAppBundleChanges
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for getAppBundleManifest operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleManifestRequest
 */
export interface DefaultApiGetAppBundleManifestRequest {
    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiGetAppBundleManifest
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for getAppBundleVersions operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleVersionsRequest
 */
export interface DefaultApiGetAppBundleVersionsRequest {
    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiGetAppBundleVersions
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for getAttachmentManifest operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAttachmentManifestRequest
 */
export interface DefaultApiGetAttachmentManifestRequest {
    /**
     * 
     * @type {AttachmentManifestRequest}
     * @memberof DefaultApiGetAttachmentManifest
     */
    readonly attachmentManifestRequest: AttachmentManifestRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiGetAttachmentManifest
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for listUsers operation in DefaultApi.
 * @export
 * @interface DefaultApiListUsersRequest
 */
export interface DefaultApiListUsersRequest {
    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiListUsers
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for login operation in DefaultApi.
 * @export
 * @interface DefaultApiLoginRequest
 */
export interface DefaultApiLoginRequest {
    /**
     * 
     * @type {LoginRequest}
     * @memberof DefaultApiLogin
     */
    readonly loginRequest: LoginRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiLogin
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for pushAppBundle operation in DefaultApi.
 * @export
 * @interface DefaultApiPushAppBundleRequest
 */
export interface DefaultApiPushAppBundleRequest {
    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiPushAppBundle
     */
    readonly xApiVersion?: string

    /**
     * ZIP file containing the new app bundle
     * @type {File}
     * @memberof DefaultApiPushAppBundle
     */
    readonly bundle?: File
}

/**
 * Request parameters for refreshToken operation in DefaultApi.
 * @export
 * @interface DefaultApiRefreshTokenRequest
 */
export interface DefaultApiRefreshTokenRequest {
    /**
     * 
     * @type {RefreshTokenRequest}
     * @memberof DefaultApiRefreshToken
     */
    readonly refreshTokenRequest: RefreshTokenRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiRefreshToken
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for resetUserPassword operation in DefaultApi.
 * @export
 * @interface DefaultApiResetUserPasswordRequest
 */
export interface DefaultApiResetUserPasswordRequest {
    /**
     * 
     * @type {ResetUserPasswordRequest}
     * @memberof DefaultApiResetUserPassword
     */
    readonly resetUserPasswordRequest: ResetUserPasswordRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiResetUserPassword
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for switchAppBundleVersion operation in DefaultApi.
 * @export
 * @interface DefaultApiSwitchAppBundleVersionRequest
 */
export interface DefaultApiSwitchAppBundleVersionRequest {
    /**
     * Version identifier to switch to
     * @type {string}
     * @memberof DefaultApiSwitchAppBundleVersion
     */
    readonly version: string

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiSwitchAppBundleVersion
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for syncPull operation in DefaultApi.
 * @export
 * @interface DefaultApiSyncPullRequest
 */
export interface DefaultApiSyncPullRequest {
    /**
     * 
     * @type {SyncPullRequest}
     * @memberof DefaultApiSyncPull
     */
    readonly syncPullRequest: SyncPullRequest

    /**
     * Filter by schemaType
     * @type {string}
     * @memberof DefaultApiSyncPull
     */
    readonly schemaType?: string

    /**
     * Maximum number of records to return
     * @type {number}
     * @memberof DefaultApiSyncPull
     */
    readonly limit?: number

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiSyncPull
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for syncPush operation in DefaultApi.
 * @export
 * @interface DefaultApiSyncPushRequest
 */
export interface DefaultApiSyncPushRequest {
    /**
     * 
     * @type {SyncPushRequest}
     * @memberof DefaultApiSyncPush
     */
    readonly syncPushRequest: SyncPushRequest

    /**
     * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @type {string}
     * @memberof DefaultApiSyncPush
     */
    readonly xApiVersion?: string
}

/**
 * Request parameters for uploadAttachment operation in DefaultApi.
 * @export
 * @interface DefaultApiUploadAttachmentRequest
 */
export interface DefaultApiUploadAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiUploadAttachment
     */
    readonly attachmentId: string

    /**
     * The binary file to upload
     * @type {File}
     * @memberof DefaultApiUploadAttachment
     */
    readonly file: File
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Change password for the currently authenticated user
     * @summary Change user password (authenticated user)\'s password
     * @param {DefaultApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changePassword(requestParameters: DefaultApiChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changePassword(requestParameters.changePasswordRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if an attachment exists
     * @param {DefaultApiCheckAttachmentExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkAttachmentExists(requestParameters: DefaultApiCheckAttachmentExistsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkAttachmentExists(requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user with specified username, password, and role
     * @summary Create a new user (admin only)
     * @param {DefaultApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUser(requestParameters: DefaultApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUser(requestParameters.createUserRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user by username
     * @summary Delete a user (admin only)
     * @param {DefaultApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUser(requestParameters: DefaultApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUser(requestParameters.username, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a specific file from the app bundle
     * @param {DefaultApiDownloadAppBundleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadAppBundleFile(requestParameters: DefaultApiDownloadAppBundleFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadAppBundleFile(requestParameters.path, requestParameters.preview, requestParameters.ifNoneMatch, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an attachment by ID
     * @param {DefaultApiDownloadAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadAttachment(requestParameters: DefaultApiDownloadAttachmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadAttachment(requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Compares two versions of the app bundle and returns detailed changes
     * @summary Get changes between two app bundle versions
     * @param {DefaultApiGetAppBundleChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppBundleChanges(requestParameters: DefaultApiGetAppBundleChangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppBundleChanges(requestParameters.current, requestParameters.target, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current custom app bundle manifest
     * @param {DefaultApiGetAppBundleManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppBundleManifest(requestParameters: DefaultApiGetAppBundleManifestRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppBundleManifest(requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of available app bundle versions
     * @param {DefaultApiGetAppBundleVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppBundleVersions(requestParameters: DefaultApiGetAppBundleVersionsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppBundleVersions(requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
     * @summary Get attachment manifest for incremental sync
     * @param {DefaultApiGetAttachmentManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAttachmentManifest(requestParameters: DefaultApiGetAttachmentManifestRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAttachmentManifest(requestParameters.attachmentManifestRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns detailed version information about the server, including build information and system details
     * @summary Get server version and system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVersion(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users in the system. Admin access required.
     * @summary List all users (admin only)
     * @param {DefaultApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listUsers(requestParameters: DefaultApiListUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsers(requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain a JWT token by providing username and password
     * @summary Authenticate user and return JWT tokens
     * @param {DefaultApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(requestParameters: DefaultApiLoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(requestParameters.loginRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a new app bundle (admin only)
     * @param {DefaultApiPushAppBundleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pushAppBundle(requestParameters: DefaultApiPushAppBundleRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pushAppBundle(requestParameters.xApiVersion, requestParameters.bundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain a new JWT token using a refresh token
     * @summary Refresh JWT token
     * @param {DefaultApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshToken(requestParameters: DefaultApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(requestParameters.refreshTokenRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password for a specified user
     * @summary Reset user password (admin only)
     * @param {DefaultApiResetUserPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetUserPassword(requestParameters: DefaultApiResetUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetUserPassword(requestParameters.resetUserPasswordRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Switch to a specific app bundle version (admin only)
     * @param {DefaultApiSwitchAppBundleVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public switchAppBundleVersion(requestParameters: DefaultApiSwitchAppBundleVersionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).switchAppBundleVersion(requestParameters.version, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}` → Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}` → Response: `change_cutoff: 200, has_more: false` 
     * @summary Pull updated records since last sync
     * @param {DefaultApiSyncPullRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public syncPull(requestParameters: DefaultApiSyncPullRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncPull(requestParameters.syncPullRequest, requestParameters.schemaType, requestParameters.limit, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Push new or updated records to the server
     * @param {DefaultApiSyncPushRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public syncPush(requestParameters: DefaultApiSyncPushRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncPush(requestParameters.syncPushRequest, requestParameters.xApiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a new attachment with specified ID
     * @param {DefaultApiUploadAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadAttachment(requestParameters: DefaultApiUploadAttachmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadAttachment(requestParameters.attachmentId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current health status of the service
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current health status of the service
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHealth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns the current health status of the service
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: RawAxiosRequestConfig): AxiosPromise<GetHealth200Response> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns the current health status of the service
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



